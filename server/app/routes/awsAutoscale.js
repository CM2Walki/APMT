const express                       = require("express");
const router                        = express.Router();
const awsAutoscale                  = require("../auto_scaling_solutions/aws_autoscale/index");
const awsAutoScaleMongoFunctions    = require("../auto_scaling_solutions/aws_autoscale/awsAutoscaleMongoFunctions");
const loadtest                      = require("loadtest");
const awsGeneral                    = require("../functions/awsgeneral");

const routeContext = "awsAutoScale";

//===============ROUTES=================
//displays our homepage
router.get("/", function(req, res){
  res.render("awsAutoscale/home", {layout: "../awsAutoscale/layouts/main", user: req.user} );
});

router.get("/getUserInfoForDeploy", function(req, res){
  awsGeneral.getUserInfoForDeploy(req.user.username, res, req, routeContext);
});

router.get("/loadtesthome", function(req, res){
  res.render("awsAutoscale/loadtesthome", {layout: "../awsAutoscale/layouts/main", user: req.user} );
});

router.get("/describeEc2Instances", function(req, res) {
  awsGeneral.getUserInfoForDescription(req.user.username, res, req)
    .then(function (data) {
      if (data) {
        const awsData = {
          "accessKeyId": data.awstoken,
          "secretAccessKey": data.awssecret,
          "region": data.awsregion,
          "s3BucketName": data.s3bucketname,
          "awsKeyName": data.awskeyname
        };
        awsGeneral.describeInstances(awsData, req, res)
          .then(function (data) {
            if (data) {
              res.send(data);
            }
          });
      }
      else {
        res.send("fail")
      }
    });
});

router.get("/describeAwsAutoscaleGroups", function(req, res) {
  awsGeneral.getUserInfoForDescription(req.user.username, res, req)
    .then(function (data) {
      if (data) {
        const awsData = {
          "accessKeyId": data.awstoken,
          "secretAccessKey": data.awssecret,
          "region": data.awsregion,
          "s3BucketName": data.s3bucketname,
          "awsKeyName": data.awskeyname
        };
        awsAutoscale.describeAutoscalingGroups(awsData, req, res)
          .then(function (data) {
            if (data) {
              res.send(data);
            }
          });
      }
      else {
        res.send("fail")
      }
    });
});

router.get("/describeAwsLoadBalancer", function(req, res) {
  awsGeneral.getUserInfoForDescription(req.user.username, res, req)
    .then(function (data) {
      if (data) {
        const awsData = {
          "accessKeyId": data.awstoken,
          "secretAccessKey": data.awssecret,
          "region": data.awsregion,
          "s3BucketName": data.s3bucketname,
          "awsKeyName": data.awskeyname
        };
        awsAutoscale.describeLoadBalancer(awsData, req, res)
          .then(function (data) {
            if (data) {
              res.send(data);
            }
          });
      }
      else {
        res.send("fail")
      }
    });
});

router.post("/deployawsautoscale", function(req, res) {
  const data = req.body;
  const appUrl =  data.giturl;
  const splitArr = appUrl.split("/");
  const appNameTemp = splitArr[splitArr.length -1];
  const appNametemparr = appNameTemp.split(".");
  const appName = appNametemparr[0];

  const awsDeployData =
    {
      "image": data.imageid,
      "launchConfig": {
        "name": "awslaunchconfig",
        "typeInst": data.typeInst
      },
      "targetGroupConfig": {
        "name": "awstargetgroup",
        "vpcId": ""
      },
      "autoScale": {
        "name": "awsAutoscale",
        "maxInst": data.maxInst,
        "minInst": data.minInst,
        "subnet": "" + data.awssubnetid,
        "upPolicy": {
          "name": "awsautoscaleUpPolicy",
          "adjustmentType": data.adjustmentType,
          "metricAggregationType": data.metricAggregationType,
          "policyType": data.policyType,
          "scalingAdjustment": data.scalingAdjustmentUp,
          "alarm": {
            "name": "awsautoscaleUpPolicyAlarm_increase",
            "ComparisonOperator": "GreaterThanOrEqualToThreshold",
            "metricName": data.metricName,
            "threshold": data.threshold,
            "description": "Scaling Up if increase above threshold",
            "Statistic":  "Average",
            "Unit": "Percent"
          }
        },
        "downPolicy": {
          "name": "awsautoscaledownPolicy",
          "adjustmentType": data.adjustmentType,
          "metricAggregationType": data.metricAggregationType,
          "policyType": data.policyType,
          "scalingAdjustment": "-" + data.scalingAdjustmentDown,
          "alarm": {
            "name": "awsautoscaleDownPolicyAlarm_Decrease",
            "ComparisonOperator": "LessThanOrEqualToThreshold",
            "metricName": data.metricName,
            "threshold": data.threshold,
            "description": "Scaling down below the threshhold",
            "Statistic":  "Average",
            "Unit": "Percent"
          }
        }
      },
      "loadBal":{
        "name": "awsloadbal",
        "subnetsArr":[ ""+ data.awssubnetid,"" + data.awssubnetid2
          ],
      },
      "application":{
        "giturl": data.giturl,
        "port": data.appPort,
        "name": appName
      }
    };

  const awsData = {
    "accessKeyId": data.awstoken,
    "secretAccessKey": data.awssecret,
    "region": data.awsregion,
    "s3BucketName": data.s3bucketname,
    "awsKeyName": data.awskeyname,
    "securityId": [data.awssecurityid]
  };

  awsAutoscale.deployAutoscaler(req.user.username, awsDeployData, awsData, req, res);
});

router.get("/terminate", function(req, res) {
  awsGeneral.getUserInfoForDescription(req.user.username, res, req)
    .then(function (data) {
      if (data) {
        const awsData = {
          "accessKeyId": data.awstoken,
          "secretAccessKey": data.awssecret,
          "region": data.awsregion,
          "s3BucketName": data.s3bucketname,
          "awsKeyName": data.awskeyname
        };
        awsAutoscale.terminateAutoScale(awsData, req.user.username, req, res);
      }
      else {
        res.send("fail")
      }
    });
});

router.post("/loadTest", function(req,res){
  formElements = req.body;
  var startTime = new Date().getTime();
  var loadTestName = formElements.testName;
  awsAutoScaleMongoFunctions.setLoadTestRecording(req.user.username,loadTestName, true)
    .then(function (set) {
      if (set) {
        console.log("Enabled");

        var interval = setInterval(function () {
          if (new Date().getTime() - startTime > formElements["maxTime"] * 1000 + 600000) {
            clearInterval(interval);
            return;
          }
          awsGeneral.getUserInfoForDescription(req.user.username, res, req)
            .then(function (data) {
              if (data) {
                const awsData = {
                  "accessKeyId": data.awstoken,
                  "secretAccessKey": data.awssecret,
                  "region": data.awsregion,
                  "s3BucketName": data.s3bucketname,
                  "awsKeyName": data.awskeyname
                };
                awsAutoscale.saveAutoscalingGroupData(awsData, req.user.username, loadTestName);
              }
            });
        }, 2000);

        awsGeneral.getServiceURL(req.user.username, routeContext)
          .then(function (url) {
            if (url) {
              console.log("Found URL informtion");
              var options = "";
              var username = req.user.username;
              options = {
                url: "http://"+ url + "/api/test",
                concurrency: formElements["numConcurrClients"], //How many clients to start in parallel.
                maxRequests: formElements["maxRequests"], //A max number of requests; after they are reached the test will end.
                timeout: formElements["maxTimeOut"], //Timeout for each generated request in milliseconds. Setting this to 0 disables timeout (default).
                requestsPerSecond: formElements["maxRequestsPerSecond"], //How many requests each client will send per second.
                maxSeconds: formElements["maxTime"],
                statusCallback: function statusCallback(error, result, latency) {
                  var timeStamp = new Date().getTime();
                  var testData = {
                    "time":timeStamp,
                    "error": error,
                    "result": result,
                    "latency": latency
                  }
                  awsAutoScaleMongoFunctions.addLoadTestRequestData(username,loadTestName,testData);
                }
              };

              loadtest.loadTest(options, function(error) {
                if (error) {
                  console.error("Got an error: %s", error);
                }
                console.log("Tests run successfully");
              });
              // here neet to trigger load and save the data
              // save information of awsKubernetes every one second
              res.render("awsAutoscale/success", {
                layout: "../awsAutoscale/layouts/main",
                user: req.user.username,
                dataForm: "Request send to Server, Plese check the graphs after the test is over",
                dataClient: "Request send to Server, Plese check the graphs after the test is over"
              });
            }
            else {
              console.log("url not found");
              res.render("awsAutoscale/failure", {
                layout: "../awsAutoscale/layouts/main",
                user: req.user.username,
                error: "App Service Is not running, PLease deploy first and then run"
              });
            }
          });
      }
      else {
        console.log("Error");
      }
    });
});

router.post("/triangleLoadTest", function(req,res){
  formElements = req.body;
  var startTime = new Date().getTime();
  var loadTestName = formElements.testName;
  awsAutoScaleMongoFunctions.setLoadTestRecording(req.user.username,loadTestName, true)
    .then(function (set) {
      if (set) {
        console.log("Enabled");

        var intervalAws = setInterval(function () {
          if (new Date().getTime() - startTime > 2000000) {
            clearInterval(intervalAws);
            return;
          }
          awsGeneral.getUserInfoForDescription(req.user.username, res, req)
            .then(function (data) {
              if (data) {
                var awsdata = {
                  "accessKeyId": data.awstoken,
                  "secretAccessKey": data.awssecret,
                  "region": data.awsregion,
                  "s3BucketName": data.s3bucketname,
                  "awsKeyName": data.awskeyname
                };
                awsAutoscale.saveAutoscalingGroupData(awsdata,req.user.username,loadTestName);
              }
            });
        }, 2000);
        var requests = 1;
        res.render("awsAutoscale/success", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          dataForm: "Request send to Server, Plese check the graphs after the test is over",
          dataClient: "Request send to Server, Plese check the graphs after the test is over"
        });
        var intervalReq = setInterval(function () {
          if (new Date().getTime() - startTime > 600000 || requests > 10000) {
            clearInterval(intervalReq);
            return;
          }

          awsGeneral.getServiceURL(req.user.username, routeContext)
            .then(function (url) {
              if (url) {
                console.log("Found URL informtion");
                console.log(url);

                console.log("requests"+requests);
                var options = "";
                var username = req.user.username;
                options = {
                  url: "http://"+url + "/api/test",
                  concurrency: formElements["numConcurrClients"], //How many clients to start in parallel.
                  maxRequests: requests * 10, //A max number of requests; after they are reached the test will end.
                  timeout: 2500, //Timeout for each generated request in milliseconds. Setting this to 0 disables timeout (default).
                  requestsPerSecond: requests, //How many requests each client will send per second.
                  //maxSeconds: formElements["maxTime"],
                  statusCallback: function statusCallback(error, result, latency) {
                    var timeStamp = new Date().getTime();
                    var testData = {
                      "time": timeStamp,
                      "error": error,
                      "result": result,
                      "latency": latency
                    }
                    awsAutoScaleMongoFunctions.addLoadTestRequestData(username, loadTestName, testData);
                  }
                };
                loadtest.loadTest(options, function (error) {
                  if (error) {
                    console.error("Got an error: %s", error);
                  }
                  console.log("Tests run successfully");
                });
                if (((new Date().getTime() - startTime) < 300000)) {
                  requests+=5;
                }
                else {
                  requests-=5;
                  if (requests <= 0) {
                    requests += 20;
                  }
                }
              }
            });
        }, 20000);
      }
      else {
        console.log("Error");
        res.render("awsAutoscale/failure", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          error: "App Service Is not running, PLease deploy first and then run"
        });
      }
    });
});

router.post("/linearIncreaseLoadTest", function(req,res){
  formElements = req.body;
  var startTime = new Date().getTime();
  var loadTestName = formElements.testName;
  awsAutoScaleMongoFunctions.setLoadTestRecording(req.user.username,loadTestName, true)
    .then(function (set) {
      if (set) {
        console.log("Enabled");

        var intervalAws = setInterval(function () {
          if (new Date().getTime() - startTime > 2000000) {
            clearInterval(intervalAws);
            return;
          }
          awsGeneral.getUserInfoForDescription(req.user.username, res, req)
            .then(function (data) {
              if (data) {
                const awsData = {
                  "accessKeyId": data.awstoken,
                  "secretAccessKey": data.awssecret,
                  "region": data.awsregion,
                  "s3BucketName": data.s3bucketname,
                  "awsKeyName": data.awskeyname
                };
                awsAutoscale.saveAutoscalingGroupData(awsData, req.user.username, loadTestName);
              }
            });

        }, 2000);
        var requests = 1;
        res.render("awsAutoscale/success", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          dataForm: "Request send to Server, Plese check the graphs after the test is over",
          dataClient: "Request send to Server, Plese check the graphs after the test is over"
        });
        var intervalReq = setInterval(function () {
          if (new Date().getTime() - startTime > 600000 || requests > 10000) {
            clearInterval(intervalReq);
            return;
          }

          awsGeneral.getServiceURL(req.user.username, routeContext)
            .then(function (url) {
              if (url) {
                console.log("Found URL informtion");
                console.log(url);

                console.log("requests"+requests);
                var options = "";
                var username = req.user.username;
                options = {
                  url: "http://"+url + "/api/test",
                  concurrency: formElements["numConcurrClients"], //How many clients to start in parallel.
                  maxRequests: requests * 10, //A max number of requests; after they are reached the test will end.
                  timeout: 2500, //Timeout for each generated request in milliseconds. Setting this to 0 disables timeout (default).
                  requestsPerSecond: requests, //How many requests each client will send per second.
                  //maxSeconds: formElements["maxTime"],
                  statusCallback: function statusCallback(error, result, latency) {
                    var timeStamp = new Date().getTime();
                    var testData = {
                      "time": timeStamp,
                      "error": error,
                      "result": result,
                      "latency": latency
                    }
                    awsAutoScaleMongoFunctions.addLoadTestRequestData(username, loadTestName, testData);
                  }
                };
                loadtest.loadTest(options, function (error) {
                  if (error) {
                    console.error("Got an error: %s", error);
                  }
                  console.log("Tests run successfully");
                });
                requests=requests+3;
                }
            });
        }, 20000);
      }
      else {
        console.log("Error");
        res.render("awsAutoscale/failure", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          error: "App Service Is not running, PLease deploy first and then run"
        });
      }
    });
});

router.post("/linearIncreaseConstantLoadTest", function(req, res) {
  formElements = req.body;
  var startTime = new Date().getTime();
  var loadTestName = formElements.testName;
  awsAutoScaleMongoFunctions.setLoadTestRecording(req.user.username,loadTestName, true)
    .then(function (set) {
      if (set) {
        console.log("Enabled");

        var intervalAws = setInterval(function () {
          if (new Date().getTime() - startTime > 2000000) {
            clearInterval(intervalAws);
            return;
          }
          awsGeneral.getUserInfoForDescription(req.user.username, res, req)
            .then(function (data) {
              if (data) {
                const awsData = {
                  "accessKeyId": data.awstoken,
                  "secretAccessKey": data.awssecret,
                  "region": data.awsregion,
                  "s3BucketName": data.s3bucketname,
                  "awsKeyName": data.awskeyname
                };
                awsAutoscale.saveAutoscalingGroupData(awsData, req.user.username, loadTestName);
              }
            });

        }, 2000);
        var requests = 1;
        res.render("awsAutoscale/success", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          dataForm: "Request send to Server, Plese check the graphs after the test is over",
          dataClient: "Request send to Server, Plese check the graphs after the test is over"
        });
        var intervalReq = setInterval(function () {
          if (new Date().getTime() - startTime > 600000 || requests > 10000) {
            clearInterval(intervalReq);
            return;
          }
          awsGeneral.getServiceURL(req.user.username, routeContext)
            .then(function (url) {
              if (url) {
                console.log("Found URL informtion");
                console.log(url);

                console.log("requests"+requests);
                var options = "";
                var username = req.user.username;
                options = {
                  url: "http://"+url + "/api/test",
                  concurrency: formElements["numConcurrClients"], //How many clients to start in parallel.
                  maxRequests: requests * 10, //A max number of requests; after they are reached the test will end.
                  timeout: 2500, //Timeout for each generated request in milliseconds. Setting this to 0 disables timeout (default).
                  requestsPerSecond: requests, //How many requests each client will send per second.
                  //maxSeconds: formElements["maxTime"],
                  statusCallback: function statusCallback(error, result, latency) {
                    var timeStamp = new Date().getTime();
                    var testData = {
                      "time": timeStamp,
                      "error": error,
                      "result": result,
                      "latency": latency
                    }
                    awsAutoScaleMongoFunctions.addLoadTestRequestData(username, loadTestName, testData);
                  }
                };
                loadtest.loadTest(options, function (error) {
                  if (error) {
                    console.error("Got an error: %s", error);
                  }
                  console.log("Tests run successfully");
                });
                if(((new Date().getTime() - startTime) < 300000) && requests < 10000)
                {
                  requests=requests+5;

                }
                else
                {
                  // the requests will be fixed now
                }
              }
            });
        }, 20000);
      }
      else {
        console.log("Error");
        res.render("awsAutoscale/failure", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          error: "App Service Is not running, PLease deploy first and then run"
        });
      }
    });
});

router.post("/upDownLoadTest", function(req,res){
  formElements = req.body;
  var flag=true;
  var startTime = new Date().getTime();
  var loadTestName = formElements.testName;
  awsAutoScaleMongoFunctions.setLoadTestRecording(req.user.username,loadTestName, true)
    .then(function (set) {
      if (set) {
        console.log("Enabled");

        var intervalAws = setInterval(function () {
          if (new Date().getTime() - startTime > 2000000) {
            clearInterval(intervalAws);
            return;
          }
          awsGeneral.getUserInfoForDescription(req.user.username, res, req)
            .then(function (data) {
              if (data) {
                var awsdata = {
                  "accessKeyId": data.awstoken,
                  "secretAccessKey": data.awssecret,
                  "region": data.awsregion,
                  "s3BucketName": data.s3bucketname,
                  "awsKeyName": data.awskeyname
                };
                awsAutoscale.saveAutoscalingGroupData(awsdata, req.user.username, loadTestName);
              }
            });

        }, 2000);
        var requests = 1;
        res.render("awsAutoscale/success", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          dataForm: "Request send to Server, Plese check the graphs after the test is over",
          dataClient: "Request send to Server, Plese check the graphs after the test is over"
        });
        var intervalReq = setInterval(function () {
          if (new Date().getTime() - startTime > 600000 || requests > 10000) {
            clearInterval(intervalReq);
            return;
          }

          awsGeneral.getServiceURL(req.user.username, routeContext)
            .then(function (url) {
              if (url) {
                console.log("Found URL informtion");
                console.log(url);

                console.log("requests"+requests);
                var options = "";
                var username = req.user.username;
                options = {
                  url: "http://"+url + "/api/test",
                  concurrency: formElements["numConcurrClients"], //How many clients to start in parallel.
                  maxRequests: requests * 10, //A max number of requests; after they are reached the test will end.
                  timeout: 2500, //Timeout for each generated request in milliseconds. Setting this to 0 disables timeout (default).
                  requestsPerSecond: requests, //How many requests each client will send per second.
                  //maxSeconds: formElements["maxTime"],
                  statusCallback: function statusCallback(error, result, latency) {
                    var timeStamp = new Date().getTime();
                    var testData = {
                      "time": timeStamp,
                      "error": error,
                      "result": result,
                      "latency": latency
                    }
                    awsAutoScaleMongoFunctions.addLoadTestRequestData(username, loadTestName, testData);
                  }
                };
                loadtest.loadTest(options, function (error) {
                  if (error) {
                    console.error("Got an error: %s", error);
                  }
                  console.log("Tests run successfully");
                });
                if(flag)
                {
                  requests = 10 + Math.floor((Math.random() * 40) + 1);
                  flag=false;
                }
                else
                {
                  requests = 50 - Math.floor((Math.random() * 40) + 1);
                  flag=true;
                }
              }
            });
        }, 20000);
      }
      else {
        console.log("Error");
        res.render("awsAutoscale/failure", {
          layout: "../awsAutoscale/layouts/main",
          user: req.user.username,
          error: "App Service Is not running, PLease deploy first and then run"
        });
      }
    });
});

router.post("/getLoadTestData", function(req,res){
  formElements = req.body;
  var loadTestName = formElements.testName;

  var datarequestElapsedS = [];
  var datatotalTimeSeconds=[];
  var requestIndex = [];
  var maxLatency = [];
  var minLatency = [];
  var meanLatency = [];
  var barRPS = [];
  var totalTimeSeconds = [];
  var errors = [];
  awsAutoScaleMongoFunctions.getTestData(req.user.username,loadTestName)
    .then(function (data) {
      if (data.length) {
        data.sort(function(a, b) {
          var aD = a.result.requestIndex, bD = b.result.requestIndex;
          return (aD) - (bD);
        });
        for(i=0;i<data.length;i++)
        {
          requestIndex.push(data[i].result.requestIndex);
          datarequestElapsedS.push(data[i].result.requestElapsed);
          datatotalTimeSeconds.push(data[i].latency.totalTimeSeconds);
          maxLatency.push(data[i].latency.maxLatencyMs);
          minLatency.push(data[i].latency.minLatencyMs);
          meanLatency.push(data[i].latency.meanLatencyMs);
          barRPS.push(data[i].latency.rps);
          totalTimeSeconds.push(data[i].latency.totalTimeSeconds);
          errors.push(data[i].latency.totalErrors);
        }
        var allData = {
          "requestIndex" : requestIndex,
          "datarequestElapsed" : datarequestElapsedS,
          "datatotalTimeSeconds" : datatotalTimeSeconds,
          "maxLatency" : maxLatency,
          "minLatency" : minLatency,
          "meanLatency" : meanLatency,
          "barRPS" : barRPS,
          "totalTimeSeconds" : totalTimeSeconds,
          "errors" : errors
        };
        res.send(allData);
      }
      else {
        var allData = {
          "requestIndex" : "",
          "datarequestElapsed" : "",
          "datatotalTimeSeconds" : "",
          "maxLatency" : "",
          "minLatency" : "",
          "meanLatency" : "",
          "barRPS" : "",
          "totalTimeSeconds" : "",
          "errors" : ""
        };
        res.send(allData);
      }
    });
});

router.get("/getCurrentData", function(req, res){
  awsGeneral.getUserInfoForDescription(req.user.username, res, req)
    .then(function (data) {
      if (data) {
        const awsData = {
          "accessKeyId": data.awstoken,
          "secretAccessKey": data.awssecret,
          "region": data.awsregion,
          "s3BucketName": data.s3bucketname,
          "awsKeyName": data.awskeyname
        };
        awsAutoscale.getCurrentData(awsData, req.user.username, req, res);
      }
      else {
        console.log("fail");
        res.send("fail")
      }
    });
});

router.use(function(req, res, next){
  // the status option, or res.statusCode = 404
  // are equivalent, however with the option we
  // get the "status" local available as well
  res.render("404", {user: req.user});
});

router.use(function(err, req, res, next){
  // we may use properties of the error object
  // here and next(err) appropriately, or if
  // we possibly recovered from the error, simply next().
  res.render("500", {user: req.user});
});
//logs user out of site, deleting them from the session, and returns to homepage

module.exports = router;
